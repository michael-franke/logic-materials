\PassOptionsToPackage{table}{xcolor}
\documentclass[nobib,nofonts]{tufte-handout}

%\geometry{showframe} % display margins for debugging page layout

%%% MF additions
% \usepackage[table]{xcolor}
\usepackage[nographicx, nohyperref, nosubcaption, nogb4e, nobiblatex]{../99-auxiliary-files/00-mypackages}
\usepackage{../99-auxiliary-files/00-mycommands}
\usepackage{../99-auxiliary-files/00-myenvironments}

\usepackage{titlesec}
\usepackage{etoolbox}
\usepackage{tikz-qtree}
\usepackage{subcaption}
\usepackage{CSPstyles}

\usepackage{pgfplots}
% externalize PGF plots
% \usepgfplotslibrary{external}
% \tikzexternalize

% \titleformat{\section}
% {\large\bfshape}{\thesection}{1em}{}

\setcounter{secnumdepth}{5}
\renewcommand\thesection{\arabic{section}}

% this length controls tha hanging indent for titles
% change the value according to your needs
\newlength\titleindent
\setlength\titleindent{0.7cm}

\pretocmd{\paragraph}{\stepcounter{subsection}}{}{}
\pretocmd{\subparagraph}{\stepcounter{subsubsection}}{}{}

\titleformat{\chapter}[block]
  {\normalfont\huge\bfseries}{}{0pt}{\hspace*{-\titleindent}}

\titleformat{\section}
  {\normalfont\Large\itshape}{\llap{\parbox{\titleindent}{\thesection\hfill}}}{0em}{}

\titleformat{\subsection}
  {\normalfont\itshape}{\llap{\parbox{\titleindent}{\thesubsection\hfill}}}{0em}{}

\titleformat{\subsubsection}
  {\normalfont\normalsize\itshape}{\llap{\parbox{\titleindent}{\thesubsubsection}}}{0em}{}

\titleformat{\paragraph}[runin]
  {\normalfont\normalsize\itshape}{}{-0.7cm}{}[\xspace \ \ \ \ ]

\titleformat{\subparagraph}[runin]
  {\normalfont\normalsize}{\llap{\parbox{\titleindent}{\thesubsubsection\hfill}}}{0em}{}

\titlespacing*{\chapter}{0pt}{0pt}{20pt}
\titlespacing*{\subsubsection}{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}
\titlespacing*{\paragraph}{0pt}{3.25ex plus 1ex minus .2ex}{0em}
\titlespacing*{\subparagraph}{0pt}{3.25ex plus 1ex minus .2ex}{0em}

\DefineNamedColor{named}{mygray2}{cmyk}{0.55,0.25,0.25,0.25}
\newcommand{\mygray}[1]{\textcolor{mygray2}{#1}}

%%% Tufte style
\usepackage{graphicx} % allow embedded images
  \setkeys{Gin}{width=\linewidth,totalheight=\textheight,keepaspectratio}
  \graphicspath{{graphics/}} % set of paths to search for images

\usepackage{fancyvrb} % extended verbatim environments
  \fvset{fontsize=\normalsize}% default font size for fancy-verbatim environments

% Standardize command font styles and environments
\newcommand{\doccmd}[1]{\texttt{\textbackslash#1}}% command name -- adds backslash automatically
\newcommand{\docopt}[1]{\ensuremath{\langle}\textrm{\textit{#1}}\ensuremath{\rangle}}% optional command argument
\newcommand{\docarg}[1]{\textrm{\textit{#1}}}% (required) command argument
\newcommand{\docenv}[1]{\textsf{#1}}% environment name
\newcommand{\docpkg}[1]{\texttt{#1}}% package name
\newcommand{\doccls}[1]{\texttt{#1}}% document class name
\newcommand{\docclsopt}[1]{\texttt{#1}}% document class option name
\newenvironment{docspec}{\begin{quote}\noindent}{\end{quote}}% command specification environment

\newcommand{\proplog}{\acro{PropLog}}
\newcommand{\EFSQ}{\ensuremath{\mathit{EFSQ}}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \usepackage[sc,osf]{mathpazo}
% \linespread{1.05}

\usepackage{turnstile}
\usetikzlibrary{patterns}
\usetikzlibrary{calc}

% TODO sort out what's needed there;
% TODO make consistent with notation in other handouts

\newcommand{\Props}{\ensuremath{\Phi}}
\newcommand{\Lang}{\ensuremath{\mathfrak{L}}}

\newcommand{\ts}{\ensuremath{\thinspace}}

\newcommand{\mybar}{\ensuremath{\ | \ }}

\renewcommand{\phi}{\ensuremath{\varphi}}

\newcommand{\ra}{\ensuremath{\rightarrow}}

\newcommand{\Bel}{\ensuremath{\Box}}
\newcommand{\CB}{\ensuremath{CB}}
\newcommand{\Poss}{\ensuremath{\Diamond}}

\newcommand{\Model}{\ensuremath{\mathcal{M}}}
\newcommand{\Models}{\ensuremath{\mathfrak{M}_{\mathcal{P},\mathcal{A}}}}
\newcommand{\AS}{\ensuremath{\mathcal{A}}}
\newcommand{\ASs}{\ensuremath{\mathfrak{A}_{\Props,i}}}
\renewcommand{\SS}{\ensuremath{\mathcal{S}}}
\newcommand{\SSs}{\ensuremath{\mathfrak{S}_{\Props,i}}}
\newcommand{\MSS}{\ensuremath{\mathcal{S}^{l}}}
\newcommand{\MSSs}{\ensuremath{\mathfrak{S}^{l}_{\Props,i}}}


\newcommand{\Aware}{\ensuremath{\mathrm{A}}}

% \newcommand{\Coloneqq}{\ensuremath{\mathrel{\mathop:}\mathrel{\mathop:}=}}
% \newcommand{\modelsweak}{\ensuremath{\sdtstile{}{*}}}
% \newcommand{\modelsweak}{\ensuremath{\mathrel{\mathop{\models^{*}}}}}
\newcommand{\modelsweak}{\ensuremath{\mathrel{\mathop{|\hspace{-0.4em}\approx}}}}
\newcommand{\modelsthree}{\ensuremath{\sttstile{}{}}}


\newcommand{\lga}{\acro{lga}}
\newcommand{\sss}{\acro{sss}}
\newcommand{\modlog}{\acro{ModLog}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Modal logic}

\author{Michael Franke}

\date{} % without \date command, current date is supplied

\begin{document}

\maketitle

\begin{abstract}
\noindent
Notions covered:
language and semantics of modal propositional logic,
modal models
.
\end{abstract}

Propositional logic and predicate logic give us formulas to talk about the \emph{here and now} (the \emph{hic et nunc}): they are to be interpreted as descriptions of how the actual world is.
For example, the sentence:
%
\begin{align*}
  \underbrace{\text{The earth is round.}}_{p}
\end{align*}
%
is to be understood as a claim about how the world is like.
If we wanted to check whether it is true or false, we would have to go search \emph{this} world, the \emph{actual world} that we live in.

Modal logics are different.
They introduce a formal language with which we can also talk about other \emph{possible worlds}.
Modal logics let us express that something \emph{should} be the case, or \emph{must} be the case or \emph{cannot possibly} be the case.
For example, in order to evaluate whether this sentence is true:
\begin{align*}
  \underbrace{\text{ It is necessary that }}_{\Box}
  \underbrace{\text{ the earth is round. }}_{p}
\end{align*}
it does not suffice to check the actual shape of the earth; we need to consider different possibilities of how the world could have been.

Modal logics usually have (at least) these two \emph{modal operators}:
\begin{center}
  \begin{tabular}{cll}
    operator   & neutral paraphrase & natural language cues \\ \hline
    $\Diamond$ & It is possible that ... & \emph{might}, \emph{may}, \emph{conceivably}, \dots \\
    $\Box$     & It is necessary that ... & \emph{must}, \emph{have to}, \emph{necessarily}, \dots \\
  \end{tabular}
\end{center}
There are many different kinds of \emph{modalities}, or, as some linguists like to say: \emph{modal flavors}.
The necessity operator $\Box$ can be interpreted to be about:
\begin{enumerate}[(i)]
  \item what one ought to do given one's parents rules and regulations;
  \item what one ought to do given a countries law;
  \item what is logically necessary;
  \item what is believed or known to be true;
  \item \dots
\end{enumerate}
Here, we will have a look at the last mentioned modality to study a modal propositional logic for talking about beliefs and knowledge, a so-called \emph{epistemic modal logic}.


\section{The language of modal logic}

Modal propositional logic (\modlog) extends propositional logic by including the new operators $\Diamond$ and $\Box$.
In simple terms, whenever $\varphi$ is a formula of \proplog, then $\varphi$, $\Box \varphi$ and $\Diamond \varphi$ are formulas of \modlog.
To make things more interesting, we will have one pair of operators $\Diamond_{i}$ and $\Box_{i}$ where $i$ is a variable for one of several \emph{agents}.

\subsection{Formulas}

Let $\mathcal{P}$ be a set of proposition letters and let $\mathcal{A}$ be a set of agents.
The language $\mathfrak{L}_{\mathcal{P},\mathcal{A}}$ of \modlog is the set of all \emph{formulas} which are recursively defined as follows:
\begin{enumerate}[(i)]
  \item Every proposition letter is a formula.
  \item If $\varphi$ is a formula, so is $\neg \varphi$, $\Box_{i} \varphi$ and $\Diamond_{i} \varphi$ for each $i \in \mathcal{A}$.
  \item If $\varphi$ and $\psi$ are formulas, so are:
        \vspace*{-0.4cm}
        \begin{multicols}{4}
          \begin{enumerate}[a.]
            \item ($\varphi \wedge \psi$)
            \item ($\varphi \vee \psi$)
            \item ($\varphi \rightarrow \psi$)
            \item ($\varphi \leftrightarrow \psi$)
          \end{enumerate}
        \end{multicols}
        \vspace*{-0.4cm}
  \item Anything that cannot be constructed by (i)--(iii) is not a formula.
\end{enumerate}


Here are examples of well-formed formulas of our multi-agent epistemic logic with paraphrases (where agent $a$ is Alex, and $b$ is Bo):
\begin{center}
  \begin{tabular}{ll}
    $\Box_{a} (p \rightarrow q)$
    & Alex believes that if $p$, then $q$.
    \\
    $p \rightarrow \Diamond_{a} \Box_{b} q$
    & If $p$ is true, then Alex considers it possible that Bo believes that $q$.
    \\
    $\Box_{a} p \wedge \Box_{b} p \wedge \neg \Box_{a} \Box_{b} p$
    & Both Alex and Bo believe that $p$, but Alex doesn't believe that Bo believes it.

  \end{tabular}
\end{center}

\subsection{Semantics of modal logic}

The semantics of \modlog is defined in terms of so-called \emph{modal models}.
Similar to \proplog a model will tell us whether any given formula is true or false.
But while models in \proplog were simple valuation functions (where we interpreted a single valuation function as something like a possible world), modal models comprise (possibly: infinitely) many possible worlds.

\paragraph{Modal models.} A \emph{modal model} for the language $\mathfrak{L}_{\mathcal{P}, \mathcal{A}}$ is a triple $\Model = \tuple{W,V,(R_i)_{i \in \mathcal{A}}}$ such that:\sidenote{
  Modal models are also often called \emph{Kripke structures}, named after the logician and philosopher of language Saul Kripke.
}
\begin{itemize}[]
  \item $W$ is a set of \emph{(possible) worlds},
  \item $V \ts \colon \ts W \times \Props  \ra \set{0,1}$
  is a \emph{valuation function}, and
  \item for each agent $i \in \mathcal{A}$, $R_i \subseteq W
  \times W$ is an \emph{accessibility relation}.
\end{itemize}
For each possible world $w$, a modal model defines $w$'s own valuation function.\sidenote{
  There can be several worlds sharing the same valuation function.
}
For each agent, there is moreover an accessibility relation $R_{i}$.
We interpret this as follows: if the actual world is $w$, then agent $i$ considers as live possibilities all the words that can be ``accessed'' or ``seen'' via relation $R_{i}$ from $w$.
We write $wR_iv$ for $\tuple{w,v} \in R_i$ and introduce the notation:
\begin{align*}
R_i(w) = \set{v \in W \mid wR_iv}
\end{align*}
to refer to the set of \emph{accessible worlds} for agent $i$ from world $w$.

Figure~\ref{fig:modal-model} below shows an example of a modal model for two agents ($\mathcal{A} = \set{a,b}$) and just two propositions letters ($\mathcal{P} = \set{p, q}$).
This model only has three possible worlds.
The diagram shows, for each possible world, the set of all proposition letters that are true in this world.
Labelled arrows are used to represent the accessibility relation for each agent.
Concretely, agent $a$ ``sees'' worlds $v$ and $u$ in $w$ (formally: $R_{a}(w) = \set{u,v}$), which is shown in the diagram in exactly two arrows with label $a$ ``leaving'' world $w$.


\begin{figure}
  \centering
  \begin{tikzpicture}
        \tikzset{breakable/.code=\ifpgfmatrix\else\tikzset{matrix of
            nodes}\fi}

        \draw [every
        label/.style={breakable},state/.style={thick,rounded
          corners,rectangle split, rectangle split parts=2,
          draw=black}] (0,0) node[state] (w) {$w$ \nodepart{second} $V
          \colon \emptyset$} (5,0) node[state] (v) {$v$
          \nodepart{second} $V \colon p,q$} (2.5,-3.3) node[state] (u)
        {$u$ \nodepart{second} $V \colon p$};

        \draw[->,every node/.style={sloped,above},thick] (w) edge node
        {$a$} (v);

        \draw[->,every node/.style={left},thick] (w) edge[loop left]
        node {$b$} ();

        \draw[<->,every node/.style={sloped,above},thick] (v) edge
        node {$a$} (u);

        \draw[->,every node/.style={right},thick] (v) edge[loop right]
        node {$a,b$} ();

        \draw[->,every node/.style={sloped,above},thick] (w) edge node
        {$a$} (u);

        \draw[->,every node/.style={below},thick] (u) edge[loop below]
        node {$a,b$} ();

      \end{tikzpicture}
  \caption{Example of a modal model with three worlds ($w$, $v$ and $u$) for two agents ($a$ and $b$) and two proposition letters ($p$ and $q$).}
  \label{fig:modal-model}
\end{figure}

\paragraph{Notation and terminology.}

In everything that follows, we implicitly restrict attention to what are called \emph{serial models}, where $R_i(w) \neq \emptyset$ for all $w$ and $i$.
We say that a model is reflexive ($r$), transitive ($t$) or Euclidean ($e$) if all of its relations $R_i$ are reflexive, transitive or Euclidean.
For $C \subseteq \set{r,t,e}$ a set of properties, let $\Models^C$ refer to the collection of all models $\Model_{\mathcal{P},\mathcal{A}}$ that have the properties selected in $C$.
Specifically:
\begin{itemize}[]
  \item $\Models^{\set{t,e}}$ are \emph{belief models}, and
  \item $\Models^{\set{r,t,e}}$ are \emph{knowledge models}.
\end{itemize}

% Exercise: write down the whole model in mathematical notation
% Exercise: draw a model for a given definition


\paragraph{Truth conditions for \modlog.}
Truth conditions for formulas of \modlog are defined relative to \emph{pointed models}.
If $\Model = \tuple{W,V,(R_a)_{a \in \mathcal{A}}}$ and $w \in W$, the pair $\Model$, $w$ is a pointed model.
Truth of a formula in a pointed model $\Model,w$ is defines as follows.
For proposition letters $p \in \mathcal{P}$, the valuation function for world $w$ decides on truth or falsity:
%
\begin{align*}
  \Model, w \models p & \text{ \ iff \  } V(w,p) = 1
\end{align*}
%
Formulas with main operators from propositional logic are treated as before:
%
\begin{align*}
  &\Model, w \models \neg \phi && \text{ \ iff \ } \Model, w \not \models \phi \\
  &\Model, w \models \phi \wedge \psi && \text{ \ iff \ } \Model, w \models \phi \text{ \ and \ } \Model, w \models \psi \\
  & \ \ \ \ \  \vdots && \ \ \ \ \ \vdots
\end{align*}
%
What is new is the treatment of modal operators.
For these, the accessibility relations are important.\sidenote{
  Essentially, modal operators are like quantifiers from predicate logic, but quantifying over ``accessible worlds.''
}
%
\begin{align*}
    & \Model, w \models \Box_i \phi & & \text{ \ iff \ } \Model, v \models
    \phi \text{ for all $v \in R_i(w)$} \\
    & \Model, w \models \Diamond_i \phi & & \text{ \ iff \ } \Model, v
    \models \phi \text{ \ for some $v \in R_i(w)$}
\end{align*}

For example, the model shown in Figure~\ref{fig:modal-model} makes the following formulas true:
\begin{itemize}[]
  \item $\Bel_j (\neg p \wedge \neg q)$  \\ ``$j$ believes that $p$ and $q$ are false''
  \item $\neg p \wedge \Bel_i p$  \\ ``$i$ falsely believes that $p$ is true''
  \item $\neg \Bel_i q \wedge \neg \Bel_i \neg q$ \\ ``$i$ is uncertain about $q$''
  \item $\neg \Bel_j p \wedge \Bel_i \Bel_j p$ \\ ``$i$ falsely believes that $j$ believes $p$''
  \item $\neg \Bel_i \Bel_j q \wedge \neg \Bel_i \neg \Bel_j q$ \\ ``$i$ is uncertain whether $j$ believes $q$''
  \item $\Bel_i (q \ra \Bel_j q \wedge \neg q \ra \Bel_j \neg q)$ \\ ``$i$ believes that $j$ knows whether $q$''
\end{itemize}


  
\newpage

% \subsection{Semantics}
% \label{sec:semantics}



% \begin{definition}[Truth \& Validity]
%   Fix $\Model = \tuple{W,V,(R_j)_{j \le i}}$ and $w \in W$ and define \textbf{truth in
%   pointed models} inductively:

% \vspace{-1em}
% \begin{minipage}{0.45\linewidth}
%   \begin{align*}
%     % \Model, w \models \bot & \text{ \  never}\\
%     % \Model, w \models \top & \text{ \ always}\\
%     \Model, w \models p & \text{ \ iff \  } V(w,p) = 1\\
%     \Model, w \models \neg \phi & \text{ \ iff \ } \Model, w \not \models \phi
%   \end{align*}
% \end{minipage}
% \begin{minipage}{0.45\linewidth}
%   \begin{align*}
%     % \Model, w \models \phi \wedge \psi & \text{ \ iff \ } \Model, w
%     % \models \phi \text{ \ and \ } \Model, w \models \psi \\
%     \Model, w \models \phi \wedge \psi & \text{ \ iff \ } \Model, w
%     \models \phi \text{ \ and \ } \Model, w \models \psi \\
%     % \Model, w \models \phi \ra \psi & \text{ \ iff \ if \ } \Model,
%     % w
%     % \models \phi \text{ \ then \ } \Model, w \models \psi \\
%     % \Model, w \models \phi \leftrightarrow \psi & \text{ \ iff \ }
%     % \Model, w
%     % \models \phi \text{ \ if and only if \ } \Model, w \models \psi
%     % \\
%     \Model, w \models \Bel_i \phi & \text{ \ iff \ } \Model, v \models
%     \phi \text{ \ for all $v \in R_i(w)$}
%     % \Model, w \models \Poss_i \phi & \text{ \ iff \ } \Model, v
%     % \models \phi \text{ \ for some $v \in R_i(w)$}
%   \end{align*}
% \end{minipage}
% \medskip \medskip

%  We say that a formula $\phi$ is \textbf{valid in a model} $\Model$,
%   $\Model \models \phi$, if for all $w \in W$ of that model $\Model, w
%   \models \phi$. We say that a formula $\phi$ is \textbf{valid in a
%     class of models} $\mathcal{N}$, $\mathcal{N} \models \phi$, if
%   $\phi$ is valid on every model in $\mathcal{N}$.
% \end{definition}


% \begin{example}[Modal Model]
%   \label{example:simple_modal_modal}
%   We consider a simple modal model for $\Props = \set{p,q}$ and two
%   agents $i$ and $j$. The following formulas are true at world $w$:

%   \begin{minipage}[t]{0.4\linewidth}
%     \vspace{0em}
%     \begin{itemize}
%     \item $\Bel_j (\neg p \wedge \neg q)$  \\ ``$j$ believes that $p$ and $q$ are false''
%     \item $\neg p \wedge \Bel_i p$  \\ ``$i$ falsely believes that $p$ is true''
%     \item $\neg \Bel_i q \wedge \neg \Bel_i \neg q$ \\ ``$i$ is uncertain about $q$''
%     \item $\neg \Bel_j p \wedge \Bel_i \Bel_j p$ \\ ``$i$ falsely believes that $j$ believes $p$''
%     \item $\neg \Bel_i \Bel_j q \wedge \neg \Bel_i \neg \Bel_j q$ \\ ``$i$ is uncertain whether $j$ believes $q$''
%     \item $\Bel_i (q \ra \Bel_j q \wedge \neg q \ra \Bel_j \neg q)$ \\ ``$i$ believes that $j$ knows whether $q$''
%     \end{itemize}
%   \end{minipage}
%   \begin{minipage}[t]{0.6\linewidth}
%     \vspace{0em}
%     \begin{center}
%       \begin{tikzpicture}
%         \tikzset{breakable/.code=\ifpgfmatrix\else\tikzset{matrix of
%             nodes}\fi}

%         \draw [every
%         label/.style={breakable},state/.style={thick,rounded
%           corners,rectangle split, rectangle split parts=2,
%           draw=black}] (0,0) node[state] (w) {$w$ \nodepart{second} $V
%           \colon \emptyset$} (5,0) node[state] (v) {$v$
%           \nodepart{second} $V \colon p,q$} (2.5,-3.3) node[state] (u)
%         {$u$ \nodepart{second} $V \colon p$};

%         \draw[->,every node/.style={sloped,above},thick] (w) edge node
%         {$i$} (v);

%         \draw[->,every node/.style={left},thick] (w) edge[loop left]
%         node {$j$} ();

%         \draw[<->,every node/.style={sloped,above},thick] (v) edge
%         node {$i$} (u);

%         \draw[->,every node/.style={right},thick] (v) edge[loop right]
%         node {$i,j$} ();

%         \draw[->,every node/.style={sloped,above},thick] (w) edge node
%         {$i$} (u);

%         \draw[->,every node/.style={below},thick] (u) edge[loop below]
%         node {$i,j$} ();

%       \end{tikzpicture}
%     \end{center}
%   \end{minipage}

% \end{example}


% \subsection{Proof System}
% \label{sec:proof-system}

% \begin{definition}[Proof System for Modal Logics]
%   A proof system for a modal logical language is given by a set of $I$
%   \textbf{inference rules} and a set $A$ of \textbf{axiom
%     schemas}. Let $I$ contain the rules:
%   \begin{itemize}
%   \item[\textbf{MP}:] from $\phi$ and $\phi \ra \psi$ infer $\psi$ \hfill (\textbf{modus ponens})
%   \item[\textbf{Nec}:] from $\phi$ infer $\Bel_i \phi$ \hfill (\textbf{necessitation})
%   \end{itemize}
%   and let $A$ always contain the \textbf{normal axiom schemata}:
%   \begin{itemize}
%   \item[\textbf{Prop}:] all substitution instances of tautologies of propositional logic
%   \item[\textbf{K}:] $(\Bel_i \phi \wedge \Bel_i (\phi \ra \psi)) \ra
%     \Bel_i \psi$
%   \end{itemize}
%   and additionally any (possibly empty) subset of the following \textbf{additional axiom schemata}:
%   \begin{itemize}
%   \item[\textbf{T}:] $\Bel_i \phi \ra \phi$ \hfill (\textbf{truth})
%   \item[\textbf{4}:] $\Bel_i \phi \ra \Bel_i \Bel_i \phi$ \hfill
%     (\textbf{positive introspection})
%   \item[\textbf{5}:] $\neg \Bel_i \phi \ra \Bel_i \neg \Bel_i \phi$ \hfill
%     (\textbf{negative introspection})
%   \end{itemize}
% \end{definition}

% \begin{definition}[Proof System, Proof]
%   A \textbf{proof} is a sequence of formulas each of which is either
%   an axiom or derived from previous formulas in the sequence by
%   application of an inference rule. For any (possibly empty)
%   subset $D$ of the additional axioms $\set{\mathbf{T},
%     \mathbf{4},\mathbf{5}}$ we write $D \vdash \phi$ if a proof exists
%   for $\phi$ in the corresponding proof system.
% \end{definition}

% \paragraph{Soundness \& Completeness}
% \label{sec:soundn-compl}

% \begin{theorem}[Soundness \& Completeness]
%   Let $C$ be a (possibly empty) subset of $\set{r,t,e}$ and let $D$ the
%   `corresponding' subset of $\set{\mathbf{T},
%     \mathbf{4},\mathbf{5}}$. Then:
%   \begin{align*}
%     \Models^C \models \phi \ \ \text{iff} \ \ D \vdash \phi\,.
%   \end{align*}
%   The ``left-to-right'' part is \textbf{completeness}, the ``right-to-left''
%   part is \textbf{soundness}.
% \end{theorem}


\end{document}
